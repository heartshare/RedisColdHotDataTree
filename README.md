# RedisColdHotDataTree
Redis冷热数据分离技术研究


![](https://i.imgur.com/giW9dls.png)

<pre>
Redis混合存储实例将所有的Key都认为是热数据，以少量的内存为代价保证所有的Key的访问请求的性能
高效且一致的。而对于value部分，在内存不足的情况下，实例本身会根据最近访问的时间，访问频度，
Value大小等维度选取出部分Value作为冷数据后台异步存储到磁盘上直到内存小于指定阈值为止。
</pre>

<pre>
在Redis混合存储实例中，我们将所有的Key都认为是热数据保存在内存中是出于以下两点考虑。
      1）Key的访问频度比Value要高很多
      2）作为KV数据库，通常的访问请求都需要先找到Key，确认Key是否存在，而要确认一个Key不
         存在，就需要以某种形式检查所有Key的集合，在内存中保留所有的Key，可以保证Key的查找
         速度与纯内存完全一致。
      3）Key的大小占比很低
      5）即使普通字符串类型，通常的业务模型里面Value要比Key大好几倍。而对于Set，List,Hash
         等集合对象，所偶有成员加起来组成的Value更是比Key大好几个数量级。

因此Redis混合存储实例的适用场景主要有以下两种
      1）数据访问不均匀，存在热点数据
      2）内存不足以放下所有数据，且Value较大（相对于Key而言）         
</pre>

<pre>
热数据->冷数据

   异步方式：
      1) 主线程在内存接近最大值时，生成一系列数据换出任务；
      2) 后台线程执行这些数据换出任务，执行完毕之后通知主线程；
      3) 主线程更新释放内存中的value，更新内存中数据字典中的value为一个简单的元信息；

   同步方式：
      如果写入流量过大，异步方式来不及换出数据，导致内存超出最大规格内存。主线程将直接
         执行数据换出任务，达到变相限流的目的。

冷数据->热数据
   异步方式：
      1) 主线程在执行命令前，先判断命令涉及的value是否都在内存中；
      2) 如果不是，生成数据加载任务，挂起该客户端，主线程继续处理其他客户端请求；
      3) 后台线程执行数据加载任务，执行完毕后通知主线程；

      主线程在内存中更新数据字典中的value，唤醒之前挂起的客户端，处理其请求。

   同步方式：
      在Lua脚本，具体命令执行阶段，如果发现有value存储在磁盘上，主线程将直接执行数据加载
      任务，保证Lua脚本和命令的语义不变。
</pre>





